# 알고리즘 개인 학습

---

<br>

## 10.01

<br>

### 1. [**N개의 최소공배수**](https://school.programmers.co.kr/learn/courses/30/lessons/12953)

<br>

> n개의 숫자를 담은 배열 arr이 입력되었을 때 이 수들의 최소공배수를 반환하는 함수 완성하기
>
> > **제한조건**  
> > 1 ≤ arr ≤ 15

<br>

- **알고리즘 구상하기**

  1. _최소공배수는 모든 arr 배열 요소에 의해 나누어 떨어져야 한다._

  모든 배열 요소가 나누어 떨어져야 하므로, 배열 요소 중 가장 큰 수를 기준으로 공배수를 찾기를 시작하였다.

    <br>

  2. _시간 복잡도 보다는 문제 풀이에 집중한다._  
     배열 arr의 최대 길이는 15이므로 시간 복잡도도 $10$에 가깝다.  
     이는 $10^8$의 시간 복잡도를 마지노선으로 염두하면 $O(n^3)$ 인 알고리즘으로 풀어도 여유롭다.  
     이에 따라, 알고리즘 시간보다는 풀이 자체에 집중하였다.

    <br>

<br>

### [JavaScript]

```JavaScript
function solution(arr) {
    arr.sort((a,b) => a-b);
    const biggestNum = arr.pop();
    let leastCommonMultiple = biggestNum;
    for (let multipleNum = 1; ; multipleNum++) {
        leastCommonMultiple = biggestNum * multipleNum;
        let isLeastCommonMultiple = true;
        for (num of arr) {
            if (leastCommonMultiple%num !== 0) {
                isLeastCommonMultiple= false;
                break;
            }
        }
        if(isLeastCommonMultiple) {
            return leastCommonMultiple;
        }
    }
}
```

<br>

> ### **Comment**
>
> 1. 중첩 for문의 break
>
>    > break는 자신이 위치한 for문을 탈출한다.  
>    > 즉, 중첩 for문에서 내부 for문을 탈출하면 **외부 for문의 코드를 이어서 실행한다.**  
>    > 따라서 break로 내부 for문을 탈출한 경우, 내부 for문을 모두 반복한 경우에 관계 없이 외부 for문의 return 문이 무조건 실행된다.  
>    > 이는 코드가 의도와 다르게 작동하는 것이므로 `flag`를 이용하여 내부 for문을 모두 순회했을 때만 return하게 해야 한다.
>
> 2. 유클리드 호제법
>    > 유클리드 호제법에 의하면, 두 정수의 최소공배수는 두 정수의 곱을 최대공약수로 나눈 값과 같다.  
>    > 이를 이용하면 간단하게 알고리즘을 구현할 수 있다.

<br>
<br>

---

<br>

## 10.12

<br>

### 2. [**의상**](https://school.programmers.co.kr/learn/courses/30/lessons/42578)

<br>

> 의상과 의상의 종류를 요소로 하는 이중 배열이 주어질 때, 서로 다른 의상의 조합의 수를 return하는 함수 완성하기
>
> > **제한조건**  
> > 1 ≤ 의상의 수 ≤ 30
>
> > **문제 풀이 조건**
> > 의상 배열 clothes의 각 행은 [의상의 이름, 의상의 종류]로 이루어짐.
> > 적어도 하나의 의상은 착용해야 함.  
> > 착용한 의상의 일부가 겹치더라도 다른 의상이 안겹치거나 추가된 경우는 서로 다른 경우로 간주  
> > 의상 종류별로 최대 1개만 착용 가능

<br>

- **알고리즘 구상하기**

  1. _종류 별 의상의 수가 필요하다: Hash table 이용_  
     종류가 겹치지 않고 의상을 조합하는 경우의 수를 구해야 하기 때문에 종류별로 의상이 총 몇 개인지 구해야 한다.  
     주어진 clothes 인자는 이중 배열로, Map 객체를 이용한 Hash table로 변환하기 용이하다.  
     Hash table의 value 값에 접근한다면 종류별 의상의 갯수를 파악할 수 있다.

    <br>

  2. _의상을 조합하는 경우의 수 구하기: 아예 착용하지 않는 경우를 +1 하기_  
     의상을 조합할 때 종류별로 반드시 1개 이상 착용할 필요는 없다. 전체 의상 중 1개만 착용하고 있어도 조합으로 인정받을 수 있다.  
     이에 따라, 종류별 의상 갯수에 아무 것도 착용하지 않는 경우를 고려해 각각 +1씩 했다.  
     가령, 모자 종류가 총 2개 있다면, 모자를 착용하지 않는 경우를 더해 2 + 1 로 산정하였다.  
     이를 종합하여 `reduce`로 종류별 의상 수가 담긴 배열의 요소들을 곱하였다.

    <br>

<br>

### [JavaScript]

```JavaScript
function solution(clothes) {
    const clothesList = new Map(clothes);
    const clothesClassList = Array.from(clothesList.values());
    const clothesClassHash = new Map();
    for (let clothesClass of clothesClassList) {
        clothesClassHash.set(clothesClass, (clothesClassHash.get(clothesClass)??0) + 1);
    }
    const totalClothesChoices = Array.from(clothesClassHash.values());
    const totalChoices = totalClothesChoices.reduce((acc, cur) => {
        return acc*(cur+1);
    },1);
    return totalChoices - 1;
}
```

<br>

> ### **Comment**

<br>
<br>

---

<br>

## 10.13

<br>

### 3. [**튜플**](https://school.programmers.co.kr/learn/courses/30/lessons/64065)

<br>

> n-tuple을 표현하는 집합이 중괄호에 담겨, 문자열 s로 주어질 때 s가 표현하는 튜플을 배열에 담아 return하기
>
> > **제한조건**  
> > 1 ≤ s ≤ $10^5$
>
> > **문제 풀이 조건**
> > s는 숫자와 중괄호, 컴마(,)로만 이루어져 있음.
> > s는 항상 중복되는 원소가 없는 튜플을 올바르게 표현함.
> > s의 길이는 5 이상 $10^6$ 이하임.

<br>

- **알고리즘 구상하기**

  1. _s는 문자열 형태로 주어진다._  
     튜플의 집합 s는 중괄호로 표현되어 있지만, 자료형은 문자열이다. 따라서 문자열에 사용할 수 있는 메서드를 이용하여 숫자만 추출해야 한다.  
     문자열에서 숫자는 컴마(,)로 구분되어 있기 때문에 `split()`을 이용하면 문자열을 배열로 변환할 수 있다.

    <br>

  2. _튜플의 집합에서 중복되는 숫자를 제거하여 집합이 표현하는 튜플을 찾아야 한다._  
     중복되는 숫자는 `Set` 자료형으로 간단하게 제거할 수 있다.

    <br>

<br>

### [JavaScript]

```JavaScript
function solution(s) {
    const removedBracket = s.slice(2,-2);
    const tupleArr = removedBracket.split('},{');
    tupleArr.sort((a,b) => a.length - b.length);
    const splitedTuple = tupleArr.join();
    const splitedTupleArr = splitedTuple.split(',');
    const removedDuplication = new Set(splitedTupleArr);
    return Array.from(removedDuplication).map((num) => Number(num))
}
```

<br>

> ### **Comment**

<br>
<br>

---
