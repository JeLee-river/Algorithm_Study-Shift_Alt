# 알고리즘 개인 학습

---

<br>

## 11.16

<br>

### 1. [**전화번호 목록**](https://school.programmers.co.kr/learn/courses/30/lessons/42577)

<br>

> 전화번호부 `phone_book`의 전화번호 중 한 번호가 다른 번호의 접두어인 경우가 하나라도 존재하면, `false` 존재하지 않으면 `true` 반환하기
>
> > **제한조건**  
> > 1 ≤ phone_book ≤ $10^6$
> > 1 ≤ 전화번호 길이 ≤ 20

<br>

- **알고리즘 구상하기**

  1. _시간복잡도를 줄이는데 집중한다._

     phone_book의 길이가 최대 $10^6$이기 때문에 이 문제는 최소한 시간복잡도 $O(n)$의 방법으로 풀이해야 한다. 이에 따라, 구현보다는 알고리즘의 효율성에 집중한다.

    <br>

  2. _적절한 자료구조 선택하기: Hash_

     이 문제를 접했을 때 가장 먼저 떠오른 방식은 반복문을 이용한 phone_book 순회였다.  
     이에 따라, 나는 아래와 같은 방식으로 알고리즘을 구현했다.  
      <br>

     ```javascript
     function solution(phone_book) {
       phone_book.sort((a, b) => b.length - a.length);

       let answer = true;
       while (phone_book.length > 1) {
         const targetString = phone_book.pop();
         phone_book.forEach((number) => {
           const prefix = number.slice(0, targetString.length);
           if (prefix === targetString) {
             answer = false;
           }
         });
         if (!answer) {
           break;
         }
       }
       return answer;
     }
     ```

     <br>

     그러나 이 방식은 최대 $10^6$ 길이인 phone_book을 매 전화번호 요소가 pop()될 때마다 순회하기 때문에 얼핏 보기에는 `while` 하나만 존재하는 것처럼 보여도, $10^6$ 만큼 반복이 중첩될 수 있다.  
     결국 구현에는 문제가 없지만, 시간이 초과되면서 다른 방도를 생각하게 되었다.

     이에 따라, 새롭게 채택된 자료구조가 Hash table이다. Hash table은 프로퍼티 접근이 $O(1)$ 만으로 이루어지기 때문에 중첩 반복의 시간복잡도가 phone_book의 길이에 영향 받지 않는다.

    <br>

<br>

### [JavaScript]

```JavaScript
function solution(phone_book) {
    const numberHash = new Map()
    phone_book.forEach((number) => {
        numberHash.set(number, number);
    })

    for (let number of phone_book){
        for(let i = 1; i <= number.length-1; i++){
            const slicedNumber = number.slice(0,i)
            if(numberHash.has(slicedNumber)){
                return false;
            }
        }
    }
    return true;
}
```

<br>

> ### **Comment**
>
> 1. 중첩 for문
>    > 중첩 for문 = 시간 복잡도 $O(n^2)$ 이라고 생각할 수 있으나, 이 문제에서 유의해야 할 점은 phone_book의 배열 요소인 전화번호들의 각 길이가 최대 20인 점이다.  
>    > 중첩 for문이 순회하는 것은 phone_book가 아닌, 길이 20의 문자열이기 때문에 최대 시간복잡도는 $10^6$ \* 20 이 된다. 이는 사실상 $O(n)$ 이라 봐도 무방하다.

<br>
<br>
