# 알고리즘 개인 학습

---

<br>

## 09.06

<br>

### 1. [**콜라 문제**](https://school.programmers.co.kr/learn/courses/30/lessons/132267)

<br>

> 빈 병 a개를 가져다주면 콜라 b병을 주는 마트가 있을 때, 빈 병 n개를 가져다주면 몇 병을 받을 수 있는지 계산하기
>
> > **제한조건**  
> > 1 ≤ b < a ≤ n ≤ 1,000,000
>
> > **문제 풀이 조건**
> > 정답은 항상 int 범위를 넘지 않는다.

<br>

- **알고리즘 구상하기**

  1. n은 최대 $10^6$ 값을 가진다.
     시간복잡도가 $10^8$이 넘지 않도록 하기 위해 $O(n)$으로 문제를 해결해야 한다.

    <br>

  2. 직접 임의의 수를 정해서 규칙 찾기  
      n, a, b를 각각 203, 2, 1로 둔 경우와 203, 5, 3로 둔 경우를 가정하여 규칙을 찾은 결과, **(n을 몫이 1이 될 때까지 a로 나눈 몫) \* b의 합이 답이 된다.**
     <br>  
      구체적인 원리는 다음과 같다.
     <br>

     1 \) 콜라 n개를 가게에 전달하기 위해 조건대로 그룹화 한다.  
      = n을 a로 나눈다.

     2 \) 나머지가 생기면 다음 콜라 교환에서 콜라의 총 합에 나머지를 더한다.

     3 \) 가게에서 주는 콜라는 n을 a로 나눈 몫(= 가게에 전달한 콜라 그룹 수)에 b를 곱한 값이다.

     4 \) 위를 종합하면 1차 콜라 교환을 거친 콜라의 총 보유량은 `(n을 a로 나눈 몫) * b + 이전 계산에서의 나머지`가 된다.

     이때, 나머지는 짝이 맞지 않아 남게 된 콜라를 의미하므로, 다음 계산에서 콜라의 총 합에 더해주어야 한다.  
      이전 계산에서 남은 콜라도 다음 콜라 교환에서 실제 내가 보유한 콜라의 총 갯수에 포함되어야 하기 떄문이다.

     5 \) 콜라의 총 보유량이 a 미만이 될 때까지 위 과정을 반복한다.

     n = 203, a = 5, b = 3 를 예시로 들어 이를 도식화하면 다음과 같다.

     | 반복횟수 | 몫  | 나머지 | 콜라 총 보유량    |
     | -------- | --- | ------ | ----------------- |
     | 1        | 40  | 3      | 40 \* 3 + 3 = 123 |
     | 2        | 24  | 3      | 24 \* 3 + 3 = 75  |
     | 3        | 15  | 0      | 15 \* 3 + 0 = 45  |
     | 4        | 9   | 0      | 9 \* 3 + 0 = 27   |
     | 5        | 5   | 2      | 5 \* 3 + 2 = 17   |
     | 6        | 3   | 2      | 3 \* 3 + 2 = 11   |
     | 7        | 2   | 1      | 2 \* 3 + 1 = 7    |
     | 8        | 1   | 2      | 1 \* 3 + 2 = 5    |
     | 9        | 1   | 0      | 1 \* 3 + 0 = 3    |

    <br>  
      
      따라서 가게에서 받은 콜라 수는 120 + 72 + 45 + 27 + 15 + 9 + 6 + 3 + 3 = 293개 이다.  
       
      이를 코드로 작성한 결과는 아래와 같다.

<br>

### [JavaScript]

```JavaScript
function solution(a, b, n) {
    let totalCoke = n;
    let answer = 0;
    while (totalCoke>=a){
        const recievedCoke = Math.floor(totalCoke/a) * b;
        totalCoke = recievedCoke + totalCoke%a;
        answer += recievedCoke;
    };
    return answer;
}
```

<br>
<br>

---

<br>

## 09.06

<br>

### 2. [**추억 점수**](https://school.programmers.co.kr/learn/courses/30/lessons/176963)

<br>

> 인물(name), 인물별 추억점수(yearning), 사진(photo)이 배열로 주어졌을 때, 사진들의 추억 점수를 return하기
>
> > **제한조건**  
> > 3 ≤ photo의 길이 ≤ 100  
> > 1 ≤ photo[i]의 길이 ≤ 100
> > 3 ≤ photo[i]의 원소(문자열)의 길이 ≤ 7
>
> > **문제 풀이 조건**  
> > 3 ≤ name의 길이 = yearning의 길이≤ 100  
> > 0은 빈 칸을 의미함.

<br>

- **알고리즘 구상하기**  
  _1. photo는 이중배열이다._  
   이중배열을 순회해야 하므로 시간복잡도가 최소 O($n^2$)이다.

  photo의 길이가 최대 $10^2$ 이고, photo[i]의 길이가 최대 $10^2$ 이므로, 기본적으로 시간복잡도가 $10^4$이다.

  **따라서, $10^8$ 의 시간복잡도로 풀기 위해서는 반드시 O($n^2$)으로 풀이해야 한다.**

    <br>

  _2. hash table을 사용하자_  
  배열을 순회하는 것 만으로 시간복잡도가 O($n^2$) 이므로, 최종 시간복잡도가 O($n^2$)이 되려면 인물에 대조되는 점수를 찾는 과정이 O(1)이어야 한다.

  만일 점수를 찾는 과정에 O(n)을 소요한다면, 인물별 점수 찾기에 O(n), 사진 하나 순회에 O(n), 배열의 모든 사진을 순회하는데 O(n)이 소요되면서 총 O($n^3$)의 시간복잡도가 나오기 때문이다.

  **이에 따라, 인물의 점수를 O(1)으로 찾기 위해, 인물:점수를 key:value 쌍으로 갖는 hash table을 생성했다.**

<br>

### [python]

```Python
from collections import defaultdict
from functools import reduce

def solution(name, yearning, photo):
    yearningScores = defaultdict(int, {name[i]:yearning[i] for i in range(len(name))})

    def changeNameIntoScore(photo):
        return reduce(lambda acc,cur: yearningScores[cur]+acc, photo, 0)

    return [changeNameIntoScore(eachPhoto) for eachPhoto in photo]
```

<br>

### [JavaScript]

```JavaScript
function solution(name, yearning, photo) {
    const yearningList = {};
    for(let i = 0; i<= name.length-1; i++){
        yearningList[name[i]] = yearning[i];
    }
    const photoScore = photo.map((eachPhoto) => {
        return eachPhoto.reduce((acc, cur) => {
            return acc + (yearningList[cur] ?? 0);
        },0);
    });
    return photoScore;
}
```

<br>

> ### **Comment**
>
> Python reduce의 콜백함수에도 lambda를 사용할 수 있다.

<br>
<br>

---

<br>

## 09.08

<br>

### 3. [**2016**](https://school.programmers.co.kr/learn/courses/30/lessons/12901)

<br>

> 윤년 2016년의 임의의 날짜, a월 b일이 주어졌을 때, 무슨 요일인지 구하기
>
> > **문제 풀이 조건**  
> > 2016년은 윤년
> > a월 b일은 실제로 존재하는 날짜임.
> > 2016년 1월 1일은 금요일

<br>

- **알고리즘 구상하기**  
  _1. 요일은 7일에 한 번 돌아온다._  
   1월 1일의 요일이 주어졌기 때문에, 주어진 날짜가 1월 1일로부터 며칠이 지났는지 파악하면 7로 나눈 나머지를 이용해 요일을 구할 수 있다.

    <br>

  _2. hash table을 사용하자_  
  0~6까지의 나머지가 각 요일들에 대응된다. key-value쌍을 가진 hash table을 연상할 수 있다.

  **hash table은 시간복잡도 O(1)으로 특정 key 값을 찾을 수 있기 때문에** '나머지:요일'을 key-value로 하는 hash table을 생성하기로 했다.

    <br>

  _3. `reduce`를 이용하자_  
  **reduce는 별도의 초기값을 설정하고 배열 요소들과 연산할 수 있다.**

  `reduce`의 초기값을 b로 설정한다면, 2016년 1월~12월까지의 각 일 수를 상수화하여 a에 따라 더해야 할 기간만 정하면 된다.

<br>

### [python]

```Python
from functools import reduce
def solution(a, b):
    DAYS = {0:'THU', 1: 'FRI', 2:'SAT', 3:'SUN', 4:'MON', 5:'TUE', 6:'WED'}
    dates = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    targetMonths = dates[0:a-1]
    totalDays = reduce(lambda acc, cur: acc+cur,targetMonths, b)
    return DAYS[totalDays%7]
```

<br>

### [JavaScript]

```JavaScript
function solution(a, b) {
    const DAYS = {0:'THU', 1: 'FRI', 2:'SAT', 3:'SUN', 4:'MON', 5:'TUE', 6:'WED'};
    const dates = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    const targetMonths = dates.slice(0, a-1);
    const totalDays = targetMonths.reduce((acc, cur) => acc+cur,b);
    return DAYS[totalDays%7];
}
```

<br>

> ### **Comment**

<br>
<br>

---

<br>

## 9.09

<br>

### 4. [**카드 뭉치**](https://school.programmers.co.kr/learn/courses/30/lessons/159994)

<br>

> 영어 단어가 적힌 두 그룹의 카드 뭉치 cards1, cards2 가 주어졌을 때, 순서를 변경하지 않고 원하는 문장을 완성할 수 있는 지 return하는 문제
>
> > **제한조건**  
> > 1 ≤ cards1, cards2의 길이 ≤ 10
> > 2 ≤ goal의 길이 ≤ cards1, cards2의 길이
>
> > **문제 풀이 조건**
> > cards1, cards2에는 서로 다른 단어만 존재
> > 반드시 카드를 사용하고 다음 카드로 넘어가야 함.
> > 한 번 사용한 카드는 다시 사용 불가
> > 순서 변경 불가, 순서대로 카드를 사용해야 함.

<br>

- **알고리즘 구상하기**  
  _1. 자료구조 결정하기: 큐(queue)_  
   카드는 가장 앞에 놓인 순서대로 사용해야 하며, 위치를 변경할 수 없다.  
   이는 즉, 순서가 있는 자료구조를 선택해야 하며 index 0에 접근할 때 시간복잡도가 낮은 유형이 best이다.  
   이에 따라, FIFO가 가능한 큐를 선택했다.

<br>

### [python]

**첫번째 풀이**

```Python
from collections import deque
def solution(cards1, cards2, goal):
    queCards1 = deque(cards1)
    queCards2 = deque(cards2)

    for el in goal:
        if len(queCards1) > 0 and queCards1[0] == el:
            queCards1.popleft()
            continue
        if len(queCards2) > 0 and queCards2[0] == el:
            queCards2.popleft()
            continue
        return "No"
    return "Yes"
```

<br>

### [JavaScript]

```JavaScript
function solution(cards1, cards2, goal) {
    let cards1El = cards1.shift();
    let cards2El = cards2.shift();
    let target = goal[0];
    if(cards1El !== target && cards2El !== target) return "No";

    while(goal.length > 0){
        target = goal.shift();
        if(cards1El === target){
            cards1El = cards1.shift()??'';
            continue;
        };
        if(cards2El === target){
            cards2El = cards2.shift()??'';
            continue;
        };
        return "No";
    };
    return "Yes";
};
```

<br>

> ### **Comment**
>
> 파이썬의 `deque`는 빈 list에 요소를 `pop`하는 메서드를 사용하면 error를 발생시킨다.  
> 이에 따라, pop을 사용하기 전에 list가 비었는지 확인하는 과정이 필요하다.
>
> 파이썬의 `and` 문법은 전자의 조건을 먼저 확인하고 후자의 조건으로 넘어간다. 즉, 서순이 중요하다!  
> 전제조건이 필요한 조건문을 체크하는 경우, 반드시 전제조건을 `and` 앞에 배치하자.

<br>
<br>

---

<br>

## 9.10

<br>

### 5. [**폰켓몬**](https://school.programmers.co.kr/learn/courses/30/lessons/1845)

<br>

> 폰켓몬 종류를 숫자로 표현한 폰켓몬 배열 nums가 주어졌을 때, 최대한 다양한 종류로 nums/2 마리를 고른다면 얻을 수 있는 폰켓몬 종류의 수 구하기
>
> > **제한조건**  
> > 1 ≤ nums의 길이 ≤ 10,000
>
> > **문제 풀이 조건**
> > 가장 많은 폰켓몬 종류를 선택하는 법이 여러 가지라도 최댓값 하나만 return

<br>

- **알고리즘 구상하기**  
  _1. 자료구조 결정하기: 해시 테이블(hash table)_  
   nums의 폰켓몬 종류가 총 몇 종류인지 구하는 것이 핵심이므로 nums 요소의 순서는 상관 없다.  
   한 종류의 폰켓몬이 여러 마리 존재할 수 있으므로, 마리 수 상관 없이 최종적으로 몇 종류가 있는지 파악할 수 있는 자료구조를 선택해야 한다.
  이에 따라, 순서(index)가 상관 없고 폰켓몬의 종류를 key값으로 하여 key-value쌍의 수를 구할 수 있는 해시 테이블을 선택했다.

<br>

### [python]

**첫번째 풀이**

```Python
from collections import defaultdict

def solution(nums):
    pocketmonCollection = defaultdict(int)
    for pocketmon in nums:
        pocketmonCollection[pocketmon]+=1

    if len(pocketmonCollection)>=len(nums)/2:
        return len(nums)/2
    return len(pocketmonCollection)
```

<br>

### [JavaScript]

```JavaScript
function solution(nums) {
    const countPocketmon = new Map();
    nums.forEach((poketMon) => {
        const target = countPocketmon.get(poketMon);
        if(target){
            countPocketmon.set(poketMon, target+1);
            return;
        }
        countPocketmon.set(poketMon, 1);
    });
    return countPocketmon.size>=nums.length/2?nums.length/2:countPocketmon.size;
}
```

<br>

> ### **Comment**
>
> JavaScript의 ` Set`` 객체를 사용하면 중복을 허용하지 않은 객체를 만들 수 있다.
이 문제는 종류별 포켓몬 수가 중요하지 않기 때문에 Map보다는  `Set`을 이용하면 더 가독성 높은 코드를 작성할 수 있다.

<br>
<br>

---
