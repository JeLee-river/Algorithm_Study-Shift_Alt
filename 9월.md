# 알고리즘 개인 학습

---

<br>

## 09.06

<br>

### 1. [**콜라 문제**](https://school.programmers.co.kr/learn/courses/30/lessons/132267)

<br>

> 빈 병 a개를 가져다주면 콜라 b병을 주는 마트가 있을 때, 빈 병 n개를 가져다주면 몇 병을 받을 수 있는지 계산하기
>
> > **제한조건**  
> > 1 ≤ b < a ≤ n ≤ 1,000,000
>
> > **문제 풀이 조건**
> > 정답은 항상 int 범위를 넘지 않는다.

<br>

- **알고리즘 구상하기**

  1. n은 최대 $10^6$ 값을 가진다.
     시간복잡도가 $10^8$이 넘지 않도록 하기 위해 $O(n)$으로 문제를 해결해야 한다.

    <br>

  2. 직접 임의의 수를 정해서 규칙 찾기  
      n, a, b를 각각 203, 2, 1로 둔 경우와 203, 5, 3로 둔 경우를 가정하여 규칙을 찾은 결과, **(n을 몫이 1이 될 때까지 a로 나눈 몫) \* b의 합이 답이 된다.**
     <br>  
      구체적인 원리는 다음과 같다.
     <br>

     1 \) 콜라 n개를 가게에 전달하기 위해 조건대로 그룹화 한다.  
      = n을 a로 나눈다.

     2 \) 나머지가 생기면 다음 콜라 교환에서 콜라의 총 합에 나머지를 더한다.

     3 \) 가게에서 주는 콜라는 n을 a로 나눈 몫(= 가게에 전달한 콜라 그룹 수)에 b를 곱한 값이다.

     4 \) 위를 종합하면 1차 콜라 교환을 거친 콜라의 총 보유량은 `(n을 a로 나눈 몫) * b + 이전 계산에서의 나머지`가 된다.

     이때, 나머지는 짝이 맞지 않아 남게 된 콜라를 의미하므로, 다음 계산에서 콜라의 총 합에 더해주어야 한다.  
      이전 계산에서 남은 콜라도 다음 콜라 교환에서 실제 내가 보유한 콜라의 총 갯수에 포함되어야 하기 떄문이다.

     5 \) 콜라의 총 보유량이 a 미만이 될 때까지 위 과정을 반복한다.

     n = 203, a = 5, b = 3 를 예시로 들어 이를 도식화하면 다음과 같다.

     | 반복횟수 | 몫  | 나머지 | 콜라 총 보유량    |
     | -------- | --- | ------ | ----------------- |
     | 1        | 40  | 3      | 40 \* 3 + 3 = 123 |
     | 2        | 24  | 3      | 24 \* 3 + 3 = 75  |
     | 3        | 15  | 0      | 15 \* 3 + 0 = 45  |
     | 4        | 9   | 0      | 9 \* 3 + 0 = 27   |
     | 5        | 5   | 2      | 5 \* 3 + 2 = 17   |
     | 6        | 3   | 2      | 3 \* 3 + 2 = 11   |
     | 7        | 2   | 1      | 2 \* 3 + 1 = 7    |
     | 8        | 1   | 2      | 1 \* 3 + 2 = 5    |
     | 9        | 1   | 0      | 1 \* 3 + 0 = 3    |

    <br>  
      
      따라서 가게에서 받은 콜라 수는 120 + 72 + 45 + 27 + 15 + 9 + 6 + 3 + 3 = 293개 이다.  
       
      이를 코드로 작성한 결과는 아래와 같다.

<br>

### [JavaScript]

```JavaScript
function solution(a, b, n) {
    let totalCoke = n;
    let answer = 0;
    while (totalCoke>=a){
        const recievedCoke = Math.floor(totalCoke/a) * b;
        totalCoke = recievedCoke + totalCoke%a;
        answer += recievedCoke;
    };
    return answer;
}
```

<br>
<br>

---

<br>

## 09.06

<br>

### 2. [**추억 점수**](https://school.programmers.co.kr/learn/courses/30/lessons/176963)

<br>

> 인물(name), 인물별 추억점수(yearning), 사진(photo)이 배열로 주어졌을 때, 사진들의 추억 점수를 return하기
>
> > **제한조건**  
> > 3 ≤ photo의 길이 ≤ 100  
> > 1 ≤ photo[i]의 길이 ≤ 100
> > 3 ≤ photo[i]의 원소(문자열)의 길이 ≤ 7
>
> > **문제 풀이 조건**  
> > 3 ≤ name의 길이 = yearning의 길이≤ 100  
> > 0은 빈 칸을 의미함.

<br>

- **알고리즘 구상하기**  
  _1. photo는 이중배열이다._  
   이중배열을 순회해야 하므로 시간복잡도가 최소 O($n^2$)이다.

  photo의 길이가 최대 $10^2$ 이고, photo[i]의 길이가 최대 $10^2$ 이므로, 기본적으로 시간복잡도가 $10^4$이다.

  **따라서, $10^8$ 의 시간복잡도로 풀기 위해서는 반드시 O($n^2$)으로 풀이해야 한다.**

    <br>

  _2. hash table을 사용하자_  
  배열을 순회하는 것 만으로 시간복잡도가 O($n^2$) 이므로, 최종 시간복잡도가 O($n^2$)이 되려면 인물에 대조되는 점수를 찾는 과정이 O(1)이어야 한다.

  만일 점수를 찾는 과정에 O(n)을 소요한다면, 인물별 점수 찾기에 O(n), 사진 하나 순회에 O(n), 배열의 모든 사진을 순회하는데 O(n)이 소요되면서 총 O($n^3$)의 시간복잡도가 나오기 때문이다.

  **이에 따라, 인물의 점수를 O(1)으로 찾기 위해, 인물:점수를 key:value 쌍으로 갖는 hash table을 생성했다.**

<br>

### [python]

```Python
from collections import defaultdict
from functools import reduce

def solution(name, yearning, photo):
    yearningScores = defaultdict(int, {name[i]:yearning[i] for i in range(len(name))})

    def changeNameIntoScore(photo):
        return reduce(lambda acc,cur: yearningScores[cur]+acc, photo, 0)

    return [changeNameIntoScore(eachPhoto) for eachPhoto in photo]
```

<br>

### [JavaScript]

```JavaScript
function solution(name, yearning, photo) {
    const yearningList = {};
    for(let i = 0; i<= name.length-1; i++){
        yearningList[name[i]] = yearning[i];
    }
    const photoScore = photo.map((eachPhoto) => {
        return eachPhoto.reduce((acc, cur) => {
            return acc + (yearningList[cur] ?? 0);
        },0);
    });
    return photoScore;
}
```

<br>

> ### **Comment**
>
> Python reduce의 콜백함수에도 lambda를 사용할 수 있다.

<br>
<br>

---

<br>

## 09.08

<br>

### 3. [**2016**](https://school.programmers.co.kr/learn/courses/30/lessons/12901)

<br>

> 윤년 2016년의 임의의 날짜, a월 b일이 주어졌을 때, 무슨 요일인지 구하기
>
> > **문제 풀이 조건**  
> > 2016년은 윤년
> > a월 b일은 실제로 존재하는 날짜임.
> > 2016년 1월 1일은 금요일

<br>

- **알고리즘 구상하기**  
  _1. 요일은 7일에 한 번 돌아온다._  
   1월 1일의 요일이 주어졌기 때문에, 주어진 날짜가 1월 1일로부터 며칠이 지났는지 파악하면 7로 나눈 나머지를 이용해 요일을 구할 수 있다.

    <br>

  _2. hash table을 사용하자_  
  0~6까지의 나머지가 각 요일들에 대응된다. key-value쌍을 가진 hash table을 연상할 수 있다.

  **hash table은 시간복잡도 O(1)으로 특정 key 값을 찾을 수 있기 때문에** '나머지:요일'을 key-value로 하는 hash table을 생성하기로 했다.

    <br>

  _3. `reduce`를 이용하자_  
  **reduce는 별도의 초기값을 설정하고 배열 요소들과 연산할 수 있다.**

  `reduce`의 초기값을 b로 설정한다면, 2016년 1월~12월까지의 각 일 수를 상수화하여 a에 따라 더해야 할 기간만 정하면 된다.

<br>

### [python]

```Python
from functools import reduce
def solution(a, b):
    DAYS = {0:'THU', 1: 'FRI', 2:'SAT', 3:'SUN', 4:'MON', 5:'TUE', 6:'WED'}
    dates = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    targetMonths = dates[0:a-1]
    totalDays = reduce(lambda acc, cur: acc+cur,targetMonths, b)
    return DAYS[totalDays%7]
```

<br>

### [JavaScript]

```JavaScript
function solution(a, b) {
    const DAYS = {0:'THU', 1: 'FRI', 2:'SAT', 3:'SUN', 4:'MON', 5:'TUE', 6:'WED'};
    const dates = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    const targetMonths = dates.slice(0, a-1);
    const totalDays = targetMonths.reduce((acc, cur) => acc+cur,b);
    return DAYS[totalDays%7];
}
```

<br>

> ### **Comment**

<br>
<br>

---

<br>

## 9.09

<br>

### 4. [**카드 뭉치**](https://school.programmers.co.kr/learn/courses/30/lessons/159994)

<br>

> 영어 단어가 적힌 두 그룹의 카드 뭉치 cards1, cards2 가 주어졌을 때, 순서를 변경하지 않고 원하는 문장을 완성할 수 있는 지 return하는 문제
>
> > **제한조건**  
> > 1 ≤ cards1, cards2의 길이 ≤ 10
> > 2 ≤ goal의 길이 ≤ cards1, cards2의 길이
>
> > **문제 풀이 조건**
> > cards1, cards2에는 서로 다른 단어만 존재
> > 반드시 카드를 사용하고 다음 카드로 넘어가야 함.
> > 한 번 사용한 카드는 다시 사용 불가
> > 순서 변경 불가, 순서대로 카드를 사용해야 함.

<br>

- **알고리즘 구상하기**  
  _1. 자료구조 결정하기: 큐(queue)_  
   카드는 가장 앞에 놓인 순서대로 사용해야 하며, 위치를 변경할 수 없다.  
   이는 즉, 순서가 있는 자료구조를 선택해야 하며 index 0에 접근할 때 시간복잡도가 낮은 유형이 best이다.  
   이에 따라, FIFO가 가능한 큐를 선택했다.

<br>

### [python]

**첫번째 풀이**

```Python
from collections import deque
def solution(cards1, cards2, goal):
    queCards1 = deque(cards1)
    queCards2 = deque(cards2)

    for el in goal:
        if len(queCards1) > 0 and queCards1[0] == el:
            queCards1.popleft()
            continue
        if len(queCards2) > 0 and queCards2[0] == el:
            queCards2.popleft()
            continue
        return "No"
    return "Yes"
```

<br>

### [JavaScript]

```JavaScript
function solution(cards1, cards2, goal) {
    let cards1El = cards1.shift();
    let cards2El = cards2.shift();
    let target = goal[0];
    if(cards1El !== target && cards2El !== target) return "No";

    while(goal.length > 0){
        target = goal.shift();
        if(cards1El === target){
            cards1El = cards1.shift()??'';
            continue;
        };
        if(cards2El === target){
            cards2El = cards2.shift()??'';
            continue;
        };
        return "No";
    };
    return "Yes";
};
```

<br>

> ### **Comment**
>
> 파이썬의 `deque`는 빈 list에 요소를 `pop`하는 메서드를 사용하면 error를 발생시킨다.  
> 이에 따라, pop을 사용하기 전에 list가 비었는지 확인하는 과정이 필요하다.
>
> 파이썬의 `and` 문법은 전자의 조건을 먼저 확인하고 후자의 조건으로 넘어간다. 즉, 서순이 중요하다!  
> 전제조건이 필요한 조건문을 체크하는 경우, 반드시 전제조건을 `and` 앞에 배치하자.

<br>
<br>

---

<br>

## 9.10

<br>

### 5. [**폰켓몬**](https://school.programmers.co.kr/learn/courses/30/lessons/1845)

<br>

> 폰켓몬 종류를 숫자로 표현한 폰켓몬 배열 nums가 주어졌을 때, 최대한 다양한 종류로 nums/2 마리를 고른다면 얻을 수 있는 폰켓몬 종류의 수 구하기
>
> > **제한조건**  
> > 1 ≤ nums의 길이 ≤ 10,000
>
> > **문제 풀이 조건**
> > 가장 많은 폰켓몬 종류를 선택하는 법이 여러 가지라도 최댓값 하나만 return

<br>

- **알고리즘 구상하기**  
  _1. 자료구조 결정하기: 해시 테이블(hash table)_  
   nums의 폰켓몬 종류가 총 몇 종류인지 구하는 것이 핵심이므로 nums 요소의 순서는 상관 없다.  
   한 종류의 폰켓몬이 여러 마리 존재할 수 있으므로, 마리 수 상관 없이 최종적으로 몇 종류가 있는지 파악할 수 있는 자료구조를 선택해야 한다.
  이에 따라, 순서(index)가 상관 없고 폰켓몬의 종류를 key값으로 하여 key-value쌍의 수를 구할 수 있는 해시 테이블을 선택했다.

<br>

### [python]

**첫번째 풀이**

```Python
from collections import defaultdict

def solution(nums):
    pocketmonCollection = defaultdict(int)
    for pocketmon in nums:
        pocketmonCollection[pocketmon]+=1

    if len(pocketmonCollection)>=len(nums)/2:
        return len(nums)/2
    return len(pocketmonCollection)
```

<br>

### [JavaScript]

```JavaScript
function solution(nums) {
    const countPocketmon = new Map();
    nums.forEach((poketMon) => {
        const target = countPocketmon.get(poketMon);
        if(target){
            countPocketmon.set(poketMon, target+1);
            return;
        }
        countPocketmon.set(poketMon, 1);
    });
    return countPocketmon.size>=nums.length/2?nums.length/2:countPocketmon.size;
}
```

<br>

> ### **Comment**
>
> JavaScript의 ` Set`` 객체를 사용하면 중복을 허용하지 않은 객체를 만들 수 있다.
이 문제는 종류별 포켓몬 수가 중요하지 않기 때문에 Map보다는  `Set`을 이용하면 더 가독성 높은 코드를 작성할 수 있다.

<br>
<br>

---

<br>

## 9.11

<br>

### 6. [**모의고사**](https://school.programmers.co.kr/learn/courses/30/lessons/42840)

<br>

> 3명의 학생이 수학문제를 규칙적으로 찍을 때, 가장 정답률이 높은 학생을 return하기
>
> > **제한조건**  
> > 1 ≤ 문제의 수(answers) ≤ 10,000
>
> > **문제 풀이 조건**
> > 1번 학생: 1, 2, 3, 4, 5 반복
> > 2번 학생: 2, 1, 2, 3, 2, 4, 2, 5 반복
> > 3번 학생: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5 반복
> > 가장 높은 점수를 받은 학생이 여럿일 경우, return하는 값을 오름차순 정렬
> > 문제의 정답은 1, 2, 3, 4, 5중 하나

<br>

- **알고리즘 구상하기**  
  _1. 학생들이 문제를 찍는 규칙(패턴) 파악하기_  
   일정 주기로 규칙이 반복되므로, 나눗셈을 이용해서 문제 순서(idx)의 주기별 패턴을 파악한다.  
   가장 일반적이고 접근하기 쉬운, 나눗셈 나머지를 이용해 규칙을 찾으면 특정 순서에 대응하는 나머지를 구할 수 있다.

  <br>

  _2. hash table로 나머지에 대응하는 점수 구하기_  
   문제 순서로 나머지를 구하면, 이 나머지에 대응하는 점수를 찾아야 한다.  
   이에 가장 적합한 자료구조는 key-value쌍을 가지는 hash table이다.

<br>

### [python]

**첫번째 풀이**

```Python

```

<br>

### [JavaScript]

```JavaScript
function solution(answers) {
    const mathHater1Answers = new Map([[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]]);
    const mathHater2Answers = new Map([[0, 1], [1, 3], [2, 4], [3, 5]]);
    const mathHater3Answers = new Map([[0, 3], [1, 1], [2, 2], [3, 4], [4, 5]]);

    const solvedResults = [0, 0, 0];

    for (let idx = 0; idx < answers.length; idx++) {
        const answer = answers[idx];
        const mathHater1Selected = mathHater1Answers.get(idx % 5);
        const mathHater2Selected = (idx % 2 === 0) ? 2 : mathHater2Answers.get(((idx-1 )/ 2) % 4);
        const mathHater3Selected = mathHater3Answers.get(parseInt(idx / 2) % 5);

        if (answer === mathHater1Selected) solvedResults[0]++;
        if (answer === mathHater2Selected) solvedResults[1]++;
        if (answer === mathHater3Selected) solvedResults[2]++;
    }

    const maxScore = Math.max(...solvedResults);
    const answer = [];

    solvedResults.forEach((score, idx) => {
        if (score === maxScore) {
            answer.push(idx + 1);
        }
    });

    return answer;
}
```

<br>

> ### **Comment**
>
> answers 배열을 순회하여 정답을 확인하는 과정을 모든 학생과 반복해야 한다. 따라서, 반복문으로 3명을 한꺼번에 검사하는 것이 가장 효율적이다.  
> 아예 규칙을 배열화하여 규칙의 길이만 고려한다면, 규칙을 찾는 복잡한 계산을 줄일 수 있다.

```javascript
const student1 = [1, 2, 3, 4, 5];
const student2 = [2, 1, 2, 3, 2, 4, 2, 5];
const student3 = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5];
let results = [0, 0, 0];

for (let i = 0; i < answers.length; i++) {
  if (answers[i] == student1[i % student1.length]) count[0]++;
  if (answers[i] == student2[i % student2.length]) count[1]++;
  if (answers[i] == student3[i % student3.length]) count[2]++;
}
```

<br>
<br>

---

<br>

## 9.12

<br>

### 7. [**과일 장수**](https://school.programmers.co.kr/learn/courses/30/lessons/135808)

<br>

> 사과 점수를 요소로 하는 배열 score가 주어졌을 때, 사과를 m개씩 나누어 담은 상자의 점수를 구하기
>
> > **제한조건**  
> > 7 ≤ score의 길이 ≤ $10^6$
>
> > **문제 풀이 조건**
> > 한 상자에 담긴 사과의 점수가 서로 다르면, 가장 낮은 점수를 기준으로 계산한다.
> > 사과는 상자 단위로 점수를 계산하며, 남은 사과는 버린다.
> > 3 ≤ m ≤ 10
> > 3 ≤ k(사과 점수) ≤ 9

<br>

- **알고리즘 구상하기**  
  _1. 일정 개수의 사과를 상자에 나누어 담는다._  
   몫과 나머지를 이용하여 사과를 분배하는 알고리즘을 구상해야 한다.  
   이 때, 상자의 점수는 무조건 가장 점수가 낮은 사과를 기준으로 계산하므로, 가능한 한 점수가 동일한 사과끼리 상자에 담아야 한다.

  <br>

  _2. 한 상자에 담긴 사과의 점수가 다른 경우를 고려하기_  
   특정 점수의 사과의 갯수가 m으로 나누어 떨어지지 않으면, 더 높거나 낮은 점수의 사과와 섞여서 담긴다.  
   이는 사과 상자의 점수에 영향을 주기 때문에 나머지를 다음 사과로 넘기는 알고리즘을 구상해야 한다.  
   = `reduce`를 이용하여 축적되는 값으로 넘겨주기

<br>

### [JavaScript]

```JavaScript
function solution(k, m, score) {
    const scoreCount = new Map();
    while(score.length > 0){
        const targetScore = score.pop();
        if(scoreCount.has(targetScore)){
            scoreCount.set(targetScore, scoreCount.get(targetScore)+1);
            continue;
        }
        scoreCount.set(targetScore, 1);
    }

    const scoreNumber = [...scoreCount.keys()].sort((a,b) => b-a);
    let answer = 0;

    scoreNumber.reduce((acc, cur) => {
        if((scoreCount.get(cur) + acc)%m === 0){
            answer += (scoreCount.get(cur) + acc)*cur;
            return 0;
        }
        answer += Math.floor((scoreCount.get(cur) + acc)/m)*m*cur;
        return (scoreCount.get(cur) + acc)%m;
    },0)
    return answer;
}

```

<br>

> ### **Comment**
>
> 더 높은 점수의 사과가 담긴 상자에서 남는 사과를 다음 상자로 넘기는 계산보다, 아예 score를 오름차순으로 정렬하고 `m`으로 나누어 그룹핑하면, 자연스럽게 그룹의 index 0번째 점수가 가장 낮은 점수로 계산된다.  
> `slice()`에서 매서드에 인자를 주지 않으면, 배열을 깊은 복사할 수 있다.

```javascript
const sortedScore = score
  .slice()
  .sort((a, b) => a - b)
  .slice(score.length % m);
for (let i = 0; i < sortedScore.length; i += m) {
  answer += sortedScore[i] * m;
}
```

<br>
<br>

---
