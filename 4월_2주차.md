# Shift Alt 알고리즘 스터디
엘리스 SW트랙 알고리즘 스터디 23.04.10 ~ 23.04.14

---
<br>

## 04.10

<br>  

### 1. [**K번째수**](https://school.programmers.co.kr/learn/courses/30/lessons/42748)  
  
<br>  

> 배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하기
>>  **제한조건**  
array의 길이는 1 이상 100 이하  
commands의 길이는 1 이상 50 이하  
>  
>> **문제 풀이 조건**  
array의 각 원소는 1 이상 100 이하  
commands의 각 원소는 길이가 3으로, 차례대로 i, j, k를 의미함.    
  
<br>  

 - **알고리즘 구상하기**  
*1. 한 array에 여러 command(commands의 원소 배열)를 적용해야 한다.*  
command 단위로 array에 적용했을 때 문제의 조건을 충족하는 함수를 통해 코드 재사용성 높이기  
*2. 자료구조 선택하기*  
배열을 slice하기 위해 특정 index에 여러번 접근해야 하므로 **Array list를 선택함.**

<br>

### [python]  

```Python
def solution(array, commands):
    def slicing(arr, req):
        start = req[0]-1
        end = req[1]
        sliced = arr[start:end]
        sliced.sort()
        return sliced[req[2]-1]
    return [slicing(array, command) for command in commands]
```

<br>

### [JavaScript]  

```JavaScript
function solution(array, commands) {
    const sliced = commands.map(cmd => array.slice(cmd[0]-1,cmd[1]).sort((a,b) => a-b));
    return commands.map((cmd, idx) => sliced[idx][cmd[2]-1]);
};
```  
<br> 

>### **Comment**  
>sort()는 유니코드 순서로 정렬하기 때문에, 숫자 오름차순은 명확한 콜백함수를 작성해야 한다.
```JavaScript
const arr = [1, 6, 4, 2, 10];
arr.sort(); // [1, 10, 2, 4, 6]
arr.sort((a,b) => a-b); // [1, 2, 4, 6, 10]
```

<br>
<br>

---
<br>

## 04.11

<br>  

### 2. [**크기가 작은 부분 문자열**](https://school.programmers.co.kr/learn/courses/30/lessons/147355)  
  
<br>  

> 문자열 t와 p가 주어질 때, t에서 p와 길이가 같은 부분문자열 중에서, 부분문자열이 나타내는 수가 p가 나타내는 수보다 작거나 같은 횟수 구하기
>>  **제한조건**  
p의 길이 ≤ t의 길이 ≤ 10,000   
>  
>> **문제 풀이 조건**  
1 ≤ p의 길이 ≤ 18     
  
<br>  

- **알고리즘 구상하기**  
*1. 부문문자열의 길이는 p와 동일하도록 제한됨*  
  부분문자열이 시작하는 index는 남은 문자열의 길이가 p의 길이만큼 확보되도록 해야 한다. -> `idx <= len(t)-len(p)`  
*2. 부분문자열은 p가 나타내는 수보다 작거나 같아야 함*  
문자열도 유니코드 순서를 기준으로 대소 비교를 할 수 있다. 따라서 p보다 유니코드 정렬순서 상 큰 수로 시작하는 부분문자열은, 문제에서 요구하는 작거나 같은 횟수에 포함될 수 없다. 따라서, 1번을 충족하면서 작거나 같은 수를 선별하여 해당 숫자로 시작하는 부분문자열만 비교했다.

<br>

### [python]  

```Python
def solution(t, p):
    start = [idx for idx, n in enumerate(t) if n<=p and idx<= len(t)-len(p)]
    
    answer = 0
    for idx in start:
        if int(t[idx:idx+len(p)]) <= int(p):
            answer += 1
    return answer
```

<br>

### [JavaScript]  

```JavaScript
function solution(t, p) {
    answer = 0;
    for(let i = 0; i<=t.length - p.length; i++){
        if(Number(t.slice(i,i+p.length))<=Number(p)){
            answer +=1;
        }
    }
    return answer;
}
```  
<br> 

>### **Comment**  


<br>
<br>

---
<br>

